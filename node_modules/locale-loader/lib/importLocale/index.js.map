{"version":3,"sources":["lib/importLocale/index.js"],"names":["localizationFolder","supportedLocales","output","all","map","locale","fileName","filePath","resolve","exists","stat","isFile","readFile","content","extractXlfData","readXlf","rawData","translatedData","sourceFolder","sourceLocale","folderPath","dirname","files","sourceData","data","original","annotations","key","value","translated","mergedData","forEach","console","log","red","source","mergedContent","generateMergedContent","writeFile","mergeToFiles","importLocale","extractKey","str","substring","length","xml2js","compact","xliff","file","Array","isArray","fileData","_attributes","body","units","unit","id","target","_text","ast","entries","sort","a","b","valueStart","offset","item","tokens","start","valueEnd","end","code","generate","type","startIdx","endIdx","annoString","join"],"mappings":"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","file":"index.js","sourcesContent":["import fs from 'fs-extra';\nimport path from 'path';\nimport xml from 'xml-js';\nimport { parse } from 'babylon';\nimport generate from 'babel-generator';\nimport escodegen from 'escodegen';\nimport chalk from 'chalk';\n\nimport getRawData from '../getRawData';\nimport defaultConfig from '../../defaultConfig';\n\nfunction extractKey(str) {\n  return str.substring(1, str.length - 1);\n}\n\nfunction extractXlfData({ locale, content }) {\n  const data = xml.xml2js(content, { compact: true });\n  const output = {};\n  if (\n    data.xliff &&\n    data.xliff.file\n  ) {\n    const files = Array.isArray(data.xliff.file) ?\n      data.xliff.file :\n      [data.xliff.file];\n    files.forEach((fileData) => {\n      if (\n        fileData._attributes &&\n        fileData._attributes['target-language'] === locale &&\n        fileData.body &&\n        fileData.body['trans-unit']\n      ) {\n        const fileName = fileData._attributes.original;\n        output[fileName] = {};\n        const units = Array.isArray(fileData.body['trans-unit']) ?\n          fileData.body['trans-unit'] :\n          [fileData.body['trans-unit']];\n        units.forEach((unit) => {\n          if (\n            unit._attributes &&\n            unit._attributes.id &&\n            unit.target &&\n            unit.target._text\n          ) {\n            output[fileName][extractKey(unit._attributes.id)] = {\n              value: unit.target._text,\n              source: unit.source._text,\n            };\n          }\n        });\n      }\n    });\n  }\n  return output;\n}\n\nasync function readXlf({\n  localizationFolder,\n  supportedLocales,\n}) {\n  const output = {};\n  await Promise.all(supportedLocales.map(async (locale) => {\n    const fileName = `${locale}.xlf`;\n    const filePath = path.resolve(localizationFolder, fileName);\n    if ((await fs.exists(filePath)) && (await fs.stat(filePath)).isFile()) {\n      const content = await fs.readFile(filePath, 'utf8');\n      output[locale] = extractXlfData({ locale, content });\n    }\n  }));\n  return output;\n}\n\nfunction generateMergedContent({\n  content,\n  ast,\n  mergedData,\n  annotations,\n}) {\n  const entries = Object.keys(mergedData)\n      .map(key => mergedData[key]).sort((a, b) => a.valueStart - b.valueStart);\n  let offset = 0;\n  let output = content;\n  entries.forEach((item) => {\n    if (item.output) {\n      const valueStart = ast.tokens[item.valueStart].start + offset;\n      const valueEnd = ast.tokens[item.valueEnd].end + offset;\n      const code = escodegen.generate({\n        type: 'Literal',\n        value: item.value,\n      });\n      output = `${output.substring(0, valueStart)}${code}${output.substring(valueEnd)}`;\n      offset += code.length - (valueEnd - valueStart);\n    } else {\n      const startIdx = ast.tokens[item.startIdx].start + offset;\n      const endIdx = ast.tokens[item.endIdx].end + offset;\n      output = `${output.substring(0, startIdx)}${output.substring(endIdx)}`;\n      offset -= endIdx - startIdx;\n    }\n  });\n  const annoString = annotations.map(a => (\n    `// @key: @#@${JSON.stringify(a.key)}@#@ @source: @#@${JSON.stringify(a.value)}@#@`\n  )).join('\\n');\n\n  return `${output}\\n${annoString}\\n`;\n}\n\nasync function mergeToFiles({\n  rawData,\n  translatedData,\n  sourceFolder,\n  sourceLocale,\n}) {\n  await Promise.all(Object.keys(translatedData).map(async (locale) => {\n    await Promise.all(Object.keys(translatedData[locale]).map(async (fileName) => {\n      const filePath = path.resolve(sourceFolder, fileName);\n      const folderPath = path.dirname(filePath);\n      if (!rawData[folderPath] || !rawData[folderPath].files[sourceLocale]) return;\n      const sourceData = rawData[folderPath].files[sourceLocale].data;\n      const original = (rawData[folderPath] &&\n        rawData[folderPath].files &&\n        rawData[folderPath].files[locale] &&\n        rawData[folderPath].files[locale].data) || {};\n\n      const annotations = Object.keys(rawData[folderPath].files[sourceLocale].data)\n        .map(key => ({\n          key,\n          value: rawData[folderPath].files[sourceLocale].data[key].value\n        }));\n\n      const translated = translatedData[locale][fileName];\n      const mergedData = {};\n\n      Object.keys(sourceData).forEach((key) => {\n        mergedData[key] = {\n          ...sourceData[key],\n        };\n      });\n\n      // convert original values into string literals\n      Object.keys(original).forEach((key) => {\n        if (!sourceData[key]) {\n          console.log(`[import-locale] ${chalk.red('{Delete}')} Key: '[${key}]', Reason: Source no longer exist.`);\n          return;\n        }\n        if (!sourceData[key].value !== original[key].source) {\n          console.log(`[import-locale] ${chalk.red('{Delete}')} Key: '[${key}]', Reason: Source value changed.`);\n          return;\n        }\n        mergedData[key] = {\n          ...mergedData[key],\n          ...original[key],\n          output: true,\n        };\n      });\n      Object.keys(translated).forEach((key) => {\n        if (!sourceData[key]) {\n          console.log(`[import-locale] ${chalk.red('{Skip}')} Key: '[${key}]', Reason: Source no longer exist.`);\n          return;\n        }\n        if (sourceData[key].value !== translated[key].source) {\n          console.log(`[import-locale] ${chalk.red('{Skip}')} Key: '[${key}]', Reason: Source value changed.`);\n          return;\n        }\n        mergedData[key] = {\n          ...mergedData[key],\n          ...translated[key],\n          output: true,\n        };\n      });\n      const mergedContent = generateMergedContent({\n        ...rawData[folderPath].files[sourceLocale],\n        mergedData,\n        annotations,\n      });\n      console.log(mergedContent);\n      await fs.writeFile(path.resolve(sourceFolder, fileName), mergedContent);\n    }));\n  }));\n}\n\nasync function importLocale({\n  sourceFolder = defaultConfig.sourceFolder,\n  localizationFolder = defaultConfig.localizationFolder,\n  sourceLocale = defaultConfig.sourceLocale,\n  supportedLocales = defaultConfig.supportedLocales,\n} = {}) {\n  const rawData = await getRawData({\n    sourceFolder,\n    sourceLocale,\n    supportedLocales,\n  });\n  const translatedData = await readXlf({\n    localizationFolder,\n    supportedLocales,\n  });\n  await mergeToFiles({\n    rawData,\n    translatedData,\n    sourceFolder,\n    sourceLocale,\n  });\n}\n\nexport default importLocale;\n\n"]}