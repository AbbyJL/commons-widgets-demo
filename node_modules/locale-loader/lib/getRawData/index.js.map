{"version":3,"sources":["lib/getRawData/index.js"],"names":["localeFile","extractAnnotations","readFile","content","annotations","ast","sourceType","idx","len","tokens","length","capturing","data","token","type","_export","_default","braceL","braceR","parseLine","key","value","startIdx","endIdx","valueStart","valueEnd","source","get","extractData","folderPath","sourceLocale","supportedLocales","readdir","localeFiles","filter","localeData","path","files","all","map","file","locale","replace","indexOf","resolve","getLocaleData","keyArray","push","label","colon","valueArray","backQuote","Error","comma","join","annotationRegExp","match","exec","set","JSON","parse","sourceFolder","loaderFiles","rawData","f","dirname","getRawData"],"mappings":"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","file":"index.js","sourcesContent":["import fs from 'fs-extra';\nimport path from 'path';\nimport { parse, tokTypes } from 'babylon';\nimport isLocaleFile from '../isLocaleFile';\nimport formatLocale from '../formatLocale';\nimport getLoaderFiles from '../getLoaderFiles';\n\nexport function parseLine(tokens, startIdx) {\n  let idx = startIdx;\n  let token = tokens[idx];\n  const keyArray = [];\n  do {\n    keyArray.push(typeof token.value !== 'undefined' ? token.value : token.type.label);\n    idx += 1;\n    token = tokens[idx];\n  } while (token.type !== tokTypes.colon);\n  const valueArray = [];\n  idx += 1;\n  token = tokens[idx];\n  const valueStart = idx;\n  let valueEnd;\n  do {\n    if (\n      token.type === tokTypes.backQuote\n    ) {\n      throw new Error('Template strings are not supported');\n    } else {\n      valueArray.push(typeof token.value !== 'undefined' ? token.value : token.type.label);\n    }\n    valueEnd = idx;\n    idx += 1;\n    token = tokens[idx];\n  } while (token.type !== tokTypes.comma && token.type !== tokTypes.braceR);\n  const value = valueArray.join('');\n  return {\n    key: keyArray.join(''),\n    value,\n    startIdx,\n    valueStart,\n    valueEnd,\n    endIdx: idx,\n  };\n}\n\nexport function extractAnnotations(content) {\n  const annotationRegExp = /\\/\\/ @key: @#@(.*)@#@.*?@source: @#@(.*)@#@/g;\n  const annotations = new Map();\n  let match;\n  /* eslint { 'no-cond-assign': 0 } */\n  while ((match = annotationRegExp.exec(content)) !== null) {\n    annotations.set(JSON.parse(match[1]), JSON.parse(match[2]));\n  }\n  return {\n    content: content.replace(annotationRegExp, ''),\n    annotations\n  };\n}\n\nexport async function extractData(localeFile) {\n  const {\n    content,\n    annotations,\n  } = extractAnnotations(await fs.readFile(localeFile, 'utf8'));\n  const ast = parse(content, { sourceType: 'module' });\n  let idx = 0;\n  const len = ast.tokens.length;\n  let capturing = false;\n  const data = {};\n  // let dataStartIndex = null;\n  // let dataEndIndex = null;\n  while (idx < len) {\n    const token = ast.tokens[idx];\n    if (\n      token.type === tokTypes._export &&\n      ast.tokens[idx + 1].type === tokTypes._default &&\n      ast.tokens[idx + 2].type === tokTypes.braceL\n    ) {\n      // dataStartIndex = ast.tokens[idx + 2].end;\n      capturing = true;\n      idx += 3;\n    } else if (capturing) {\n      if (token.type === tokTypes.braceR) {\n        // dataEndIndex = token.start;\n        break;\n      } else {\n        const {\n          key,\n          value,\n          startIdx,\n          endIdx,\n          valueStart,\n          valueEnd,\n        } = parseLine(ast.tokens, idx);\n        data[key] = {\n          key,\n          value,\n          valueStart,\n          valueEnd,\n          startIdx,\n          endIdx,\n          source: annotations.get(key),\n        };\n        if (ast.tokens[endIdx].type !== tokTypes.braceR) {\n          idx = endIdx + 1;\n        } else {\n          // dataEndIndex = ast.tokens[endIdx].start;\n          break;\n        }\n      }\n    } else {\n      idx += 1;\n    }\n  }\n  return {\n    content,\n    data,\n    ast,\n    // dataStartIndex,\n    // dataEndIndex,\n  };\n}\n\nexport async function getLocaleData({ folderPath, sourceLocale, supportedLocales }) {\n  const localeFiles = (await fs.readdir(folderPath)).filter(isLocaleFile);\n  const localeData = {\n    path: folderPath,\n    files: {},\n  };\n  await Promise.all(localeFiles.map(async (file) => {\n    const locale = formatLocale(file.replace(/\\.(js|json)$/i, ''));\n    if (locale === sourceLocale || supportedLocales.indexOf(locale) > -1) {\n      localeData.files[locale] = {\n        file,\n        locale,\n        ...(await extractData(path.resolve(folderPath, file))),\n      };\n    }\n  }));\n  return localeData;\n}\n\nexport default async function getRawData({\n  sourceFolder,\n  sourceLocale,\n  supportedLocales,\n}) {\n  const loaderFiles = await getLoaderFiles(sourceFolder);\n  const rawData = {};\n  await Promise.all(loaderFiles.map(async (f) => {\n    const folderPath = path.resolve(path.dirname(f));\n    rawData[folderPath] = await getLocaleData({\n      folderPath,\n      sourceLocale,\n      supportedLocales,\n    });\n  }));\n  return rawData;\n}\n"]}